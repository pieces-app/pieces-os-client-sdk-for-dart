//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.12

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

import '/api_helper.dart';
import '/model/tlp_language_descriptor.dart' show TLPLanguageDescriptor;


class TLPLanguageMap {
  /// Returns a new [TLPLanguageMap] instance.
  TLPLanguageMap({
    this.batchfile,
    this.c,
    this.coffeescript,
    this.cpp,
    this.csharp,
    this.css,
    this.dart,
    this.erlang,
    this.go,
    this.haskell,
    this.html,
    this.java,
    this.javascript,
    this.lua,
    this.markdown,
    this.matlab,
    this.objectivec,
    this.perl,
    this.php,
    this.powershell,
    this.python,
    this.r,
    this.ruby,
    this.rust,
    this.scala,
    this.shellscript,
    this.sql,
    this.swift,
    this.tex,
    this.typescript,
    this.toml,
    this.yaml,
    this.json,
    this.groovy,
    this.kotlin,
    this.emacslisp,
    this.clojure,
    this.elixir,
    this.xml,
    this.solidity,
    this.systemverilog,
    this.asp,
    this.coldfusion,
  });

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? batchfile;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? c;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? coffeescript;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? cpp;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? csharp;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? css;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? dart;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? erlang;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? go;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? haskell;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? html;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? java;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? javascript;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? lua;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? markdown;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? matlab;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? objectivec;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? perl;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? php;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? powershell;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? python;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? r;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? ruby;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? rust;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? scala;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? shellscript;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? sql;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? swift;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? tex;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? typescript;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? toml;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? yaml;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? json;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? groovy;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? kotlin;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? emacslisp;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? clojure;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? elixir;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? xml;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? solidity;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? systemverilog;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? asp;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  TLPLanguageDescriptor? coldfusion;

  @override
  bool operator ==(Object other) => identical(this, other) || other is TLPLanguageMap &&
     other.batchfile == batchfile &&
     other.c == c &&
     other.coffeescript == coffeescript &&
     other.cpp == cpp &&
     other.csharp == csharp &&
     other.css == css &&
     other.dart == dart &&
     other.erlang == erlang &&
     other.go == go &&
     other.haskell == haskell &&
     other.html == html &&
     other.java == java &&
     other.javascript == javascript &&
     other.lua == lua &&
     other.markdown == markdown &&
     other.matlab == matlab &&
     other.objectivec == objectivec &&
     other.perl == perl &&
     other.php == php &&
     other.powershell == powershell &&
     other.python == python &&
     other.r == r &&
     other.ruby == ruby &&
     other.rust == rust &&
     other.scala == scala &&
     other.shellscript == shellscript &&
     other.sql == sql &&
     other.swift == swift &&
     other.tex == tex &&
     other.typescript == typescript &&
     other.toml == toml &&
     other.yaml == yaml &&
     other.json == json &&
     other.groovy == groovy &&
     other.kotlin == kotlin &&
     other.emacslisp == emacslisp &&
     other.clojure == clojure &&
     other.elixir == elixir &&
     other.xml == xml &&
     other.solidity == solidity &&
     other.systemverilog == systemverilog &&
     other.asp == asp &&
     other.coldfusion == coldfusion;

  @override
  int get hashCode =>
    // ignore: unnecessary_parenthesis
    (batchfile == null ? 0 : batchfile!.hashCode) +
    (c == null ? 0 : c!.hashCode) +
    (coffeescript == null ? 0 : coffeescript!.hashCode) +
    (cpp == null ? 0 : cpp!.hashCode) +
    (csharp == null ? 0 : csharp!.hashCode) +
    (css == null ? 0 : css!.hashCode) +
    (dart == null ? 0 : dart!.hashCode) +
    (erlang == null ? 0 : erlang!.hashCode) +
    (go == null ? 0 : go!.hashCode) +
    (haskell == null ? 0 : haskell!.hashCode) +
    (html == null ? 0 : html!.hashCode) +
    (java == null ? 0 : java!.hashCode) +
    (javascript == null ? 0 : javascript!.hashCode) +
    (lua == null ? 0 : lua!.hashCode) +
    (markdown == null ? 0 : markdown!.hashCode) +
    (matlab == null ? 0 : matlab!.hashCode) +
    (objectivec == null ? 0 : objectivec!.hashCode) +
    (perl == null ? 0 : perl!.hashCode) +
    (php == null ? 0 : php!.hashCode) +
    (powershell == null ? 0 : powershell!.hashCode) +
    (python == null ? 0 : python!.hashCode) +
    (r == null ? 0 : r!.hashCode) +
    (ruby == null ? 0 : ruby!.hashCode) +
    (rust == null ? 0 : rust!.hashCode) +
    (scala == null ? 0 : scala!.hashCode) +
    (shellscript == null ? 0 : shellscript!.hashCode) +
    (sql == null ? 0 : sql!.hashCode) +
    (swift == null ? 0 : swift!.hashCode) +
    (tex == null ? 0 : tex!.hashCode) +
    (typescript == null ? 0 : typescript!.hashCode) +
    (toml == null ? 0 : toml!.hashCode) +
    (yaml == null ? 0 : yaml!.hashCode) +
    (json == null ? 0 : json!.hashCode) +
    (groovy == null ? 0 : groovy!.hashCode) +
    (kotlin == null ? 0 : kotlin!.hashCode) +
    (emacslisp == null ? 0 : emacslisp!.hashCode) +
    (clojure == null ? 0 : clojure!.hashCode) +
    (elixir == null ? 0 : elixir!.hashCode) +
    (xml == null ? 0 : xml!.hashCode) +
    (solidity == null ? 0 : solidity!.hashCode) +
    (systemverilog == null ? 0 : systemverilog!.hashCode) +
    (asp == null ? 0 : asp!.hashCode) +
    (coldfusion == null ? 0 : coldfusion!.hashCode);

  @override
  String toString() => 'TLPLanguageMap[batchfile=$batchfile, c=$c, coffeescript=$coffeescript, cpp=$cpp, csharp=$csharp, css=$css, dart=$dart, erlang=$erlang, go=$go, haskell=$haskell, html=$html, java=$java, javascript=$javascript, lua=$lua, markdown=$markdown, matlab=$matlab, objectivec=$objectivec, perl=$perl, php=$php, powershell=$powershell, python=$python, r=$r, ruby=$ruby, rust=$rust, scala=$scala, shellscript=$shellscript, sql=$sql, swift=$swift, tex=$tex, typescript=$typescript, toml=$toml, yaml=$yaml, json=$json, groovy=$groovy, kotlin=$kotlin, emacslisp=$emacslisp, clojure=$clojure, elixir=$elixir, xml=$xml, solidity=$solidity, systemverilog=$systemverilog, asp=$asp, coldfusion=$coldfusion]';

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (this.batchfile != null) {
      _json[r'batchfile'] = batchfile?.toJson();
    }
    if (this.c != null) {
      _json[r'c'] = c?.toJson();
    }
    if (this.coffeescript != null) {
      _json[r'coffeescript'] = coffeescript?.toJson();
    }
    if (this.cpp != null) {
      _json[r'cpp'] = cpp?.toJson();
    }
    if (this.csharp != null) {
      _json[r'csharp'] = csharp?.toJson();
    }
    if (this.css != null) {
      _json[r'css'] = css?.toJson();
    }
    if (this.dart != null) {
      _json[r'dart'] = dart?.toJson();
    }
    if (this.erlang != null) {
      _json[r'erlang'] = erlang?.toJson();
    }
    if (this.go != null) {
      _json[r'go'] = go?.toJson();
    }
    if (this.haskell != null) {
      _json[r'haskell'] = haskell?.toJson();
    }
    if (this.html != null) {
      _json[r'html'] = html?.toJson();
    }
    if (this.java != null) {
      _json[r'java'] = java?.toJson();
    }
    if (this.javascript != null) {
      _json[r'javascript'] = javascript?.toJson();
    }
    if (this.lua != null) {
      _json[r'lua'] = lua?.toJson();
    }
    if (this.markdown != null) {
      _json[r'markdown'] = markdown?.toJson();
    }
    if (this.matlab != null) {
      _json[r'matlab'] = matlab?.toJson();
    }
    if (this.objectivec != null) {
      _json[r'objectivec'] = objectivec?.toJson();
    }
    if (this.perl != null) {
      _json[r'perl'] = perl?.toJson();
    }
    if (this.php != null) {
      _json[r'php'] = php?.toJson();
    }
    if (this.powershell != null) {
      _json[r'powershell'] = powershell?.toJson();
    }
    if (this.python != null) {
      _json[r'python'] = python?.toJson();
    }
    if (this.r != null) {
      _json[r'r'] = r?.toJson();
    }
    if (this.ruby != null) {
      _json[r'ruby'] = ruby?.toJson();
    }
    if (this.rust != null) {
      _json[r'rust'] = rust?.toJson();
    }
    if (this.scala != null) {
      _json[r'scala'] = scala?.toJson();
    }
    if (this.shellscript != null) {
      _json[r'shellscript'] = shellscript?.toJson();
    }
    if (this.sql != null) {
      _json[r'sql'] = sql?.toJson();
    }
    if (this.swift != null) {
      _json[r'swift'] = swift?.toJson();
    }
    if (this.tex != null) {
      _json[r'tex'] = tex?.toJson();
    }
    if (this.typescript != null) {
      _json[r'typescript'] = typescript?.toJson();
    }
    if (this.toml != null) {
      _json[r'toml'] = toml?.toJson();
    }
    if (this.yaml != null) {
      _json[r'yaml'] = yaml?.toJson();
    }
    if (this.json != null) {
      _json[r'json'] = json?.toJson();
    }
    if (this.groovy != null) {
      _json[r'groovy'] = groovy?.toJson();
    }
    if (this.kotlin != null) {
      _json[r'kotlin'] = kotlin?.toJson();
    }
    if (this.emacslisp != null) {
      _json[r'emacslisp'] = emacslisp?.toJson();
    }
    if (this.clojure != null) {
      _json[r'clojure'] = clojure?.toJson();
    }
    if (this.elixir != null) {
      _json[r'elixir'] = elixir?.toJson();
    }
    if (this.xml != null) {
      _json[r'xml'] = xml?.toJson();
    }
    if (this.solidity != null) {
      _json[r'solidity'] = solidity?.toJson();
    }
    if (this.systemverilog != null) {
      _json[r'systemverilog'] = systemverilog?.toJson();
    }
    if (this.asp != null) {
      _json[r'asp'] = asp?.toJson();
    }
    if (this.coldfusion != null) {
      _json[r'coldfusion'] = coldfusion?.toJson();
    }
    return _json;
  }

  /// Returns a new [TLPLanguageMap] instance and imports its values from
  /// [value] if it's a [Map], null otherwise.
  // ignore: prefer_constructors_over_static_methods
  static TLPLanguageMap? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      // Ensure that the map contains the required keys.
      // Note 1: the values aren't checked for validity beyond being non-null.
      // Note 2: this code is stripped in release mode!
      assert(() {
        requiredKeys.forEach((key) {
          assert(json.containsKey(key), 'Required key "TLPLanguageMap[$key]" is missing from JSON.');
          assert(json[key] != null, 'Required key "TLPLanguageMap[$key]" has a null value in JSON.');
        });
        return true;
      }());

      return TLPLanguageMap(
        batchfile: TLPLanguageDescriptor.fromJson(json[r'batchfile']),
        c: TLPLanguageDescriptor.fromJson(json[r'c']),
        coffeescript: TLPLanguageDescriptor.fromJson(json[r'coffeescript']),
        cpp: TLPLanguageDescriptor.fromJson(json[r'cpp']),
        csharp: TLPLanguageDescriptor.fromJson(json[r'csharp']),
        css: TLPLanguageDescriptor.fromJson(json[r'css']),
        dart: TLPLanguageDescriptor.fromJson(json[r'dart']),
        erlang: TLPLanguageDescriptor.fromJson(json[r'erlang']),
        go: TLPLanguageDescriptor.fromJson(json[r'go']),
        haskell: TLPLanguageDescriptor.fromJson(json[r'haskell']),
        html: TLPLanguageDescriptor.fromJson(json[r'html']),
        java: TLPLanguageDescriptor.fromJson(json[r'java']),
        javascript: TLPLanguageDescriptor.fromJson(json[r'javascript']),
        lua: TLPLanguageDescriptor.fromJson(json[r'lua']),
        markdown: TLPLanguageDescriptor.fromJson(json[r'markdown']),
        matlab: TLPLanguageDescriptor.fromJson(json[r'matlab']),
        objectivec: TLPLanguageDescriptor.fromJson(json[r'objectivec']),
        perl: TLPLanguageDescriptor.fromJson(json[r'perl']),
        php: TLPLanguageDescriptor.fromJson(json[r'php']),
        powershell: TLPLanguageDescriptor.fromJson(json[r'powershell']),
        python: TLPLanguageDescriptor.fromJson(json[r'python']),
        r: TLPLanguageDescriptor.fromJson(json[r'r']),
        ruby: TLPLanguageDescriptor.fromJson(json[r'ruby']),
        rust: TLPLanguageDescriptor.fromJson(json[r'rust']),
        scala: TLPLanguageDescriptor.fromJson(json[r'scala']),
        shellscript: TLPLanguageDescriptor.fromJson(json[r'shellscript']),
        sql: TLPLanguageDescriptor.fromJson(json[r'sql']),
        swift: TLPLanguageDescriptor.fromJson(json[r'swift']),
        tex: TLPLanguageDescriptor.fromJson(json[r'tex']),
        typescript: TLPLanguageDescriptor.fromJson(json[r'typescript']),
        toml: TLPLanguageDescriptor.fromJson(json[r'toml']),
        yaml: TLPLanguageDescriptor.fromJson(json[r'yaml']),
        json: TLPLanguageDescriptor.fromJson(json[r'json']),
        groovy: TLPLanguageDescriptor.fromJson(json[r'groovy']),
        kotlin: TLPLanguageDescriptor.fromJson(json[r'kotlin']),
        emacslisp: TLPLanguageDescriptor.fromJson(json[r'emacslisp']),
        clojure: TLPLanguageDescriptor.fromJson(json[r'clojure']),
        elixir: TLPLanguageDescriptor.fromJson(json[r'elixir']),
        xml: TLPLanguageDescriptor.fromJson(json[r'xml']),
        solidity: TLPLanguageDescriptor.fromJson(json[r'solidity']),
        systemverilog: TLPLanguageDescriptor.fromJson(json[r'systemverilog']),
        asp: TLPLanguageDescriptor.fromJson(json[r'asp']),
        coldfusion: TLPLanguageDescriptor.fromJson(json[r'coldfusion']),
      );
    }
    return null;
  }

  static List<TLPLanguageMap> listFromJson(dynamic json, {bool growable = false,}) {
    final result = <TLPLanguageMap>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = TLPLanguageMap.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  static Map<String, TLPLanguageMap> mapFromJson(dynamic json) {
    final map = <String, TLPLanguageMap>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = TLPLanguageMap.fromJson(entry.value);
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  // maps a json object with a list of TLPLanguageMap-objects as value to a dart map
  static Map<String, List<TLPLanguageMap>> mapListFromJson(dynamic json, {bool growable = false,}) {
    final map = <String, List<TLPLanguageMap>>{};
    if (json is Map && json.isNotEmpty) {
      // ignore: parameter_assignments
      json = json.cast<String, dynamic>();
      for (final entry in json.entries) {
        map[entry.key] = TLPLanguageMap.listFromJson(entry.value, growable: growable,);
      }
    }
    return map;
  }

  static Map<String, dynamic> mapToJson(Map<String, TLPLanguageMap> map) {
    final jsonMap = <String, dynamic>{};
    map.forEach((key, value) {
      jsonMap[key] = value.toJson();
    });
    return jsonMap;
  }

  /// The list of required keys that must be present in a JSON.
  static const requiredKeys = <String>{
  };
}

